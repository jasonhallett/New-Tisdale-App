<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PDF Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #0b1020; color: #fff; }
    .toolbar { position: sticky; top: 0; z-index: 10; background: #0b1020; border-bottom: 1px solid #1e293b; }
    .btn {
      background: #111827; color: #fff; border: 1px solid #1f2937; padding: 8px 12px; border-radius: 8px;
      font-weight: 500; font-size: 14px; cursor: pointer; transition: transform .04s ease;
    }
    .btn:hover { background: #1f2937; }
    .btn:active { transform: translateY(1px); }
    .btn[disabled] { opacity:.5; cursor:not-allowed; }
    iframe, embed { width: 100%; height: calc(100dvh - 56px); background: #1f2937; border: 0; }
    .badge { font-size: 12px; opacity: .8; }
  </style>
</head>
<body>
  <div class="toolbar w-full">
    <div class="max-w-screen-2xl mx-auto px-3 py-2 flex items-center gap-2">
      <button id="btnPrint" class="btn">Print</button>
      <button id="btnDownload" class="btn">Save to Files</button>
      <button id="btnImport" class="btn" disabled title="Coming soon">Import to Fleetio Work Order</button>
      <div class="flex-1"></div>
      <span id="fileMeta" class="badge"></span>
      <button id="btnClose" class="btn">Close</button>
    </div>
  </div>

  <!-- We use <iframe>. If your environment renders better with <embed>, swap the tag below. -->
  <iframe id="pdfFrame" src="" title="PDF"></iframe>

  <script>
    (function () {
      const qs = new URLSearchParams(location.search);
      const srcParam = qs.get("src");             // expected: blob:... | data:application/pdf... | https://...
      const filename = qs.get("filename") || "document.pdf";
      const inspectionId = qs.get("id") || "";    // optional, for display/metadata only

      const frame = document.getElementById("pdfFrame");
      const meta = document.getElementById("fileMeta");
      const btnPrint = document.getElementById("btnPrint");
      const btnDownload = document.getElementById("btnDownload");
      const btnClose = document.getElementById("btnClose");
      const btnImport = document.getElementById("btnImport");

      // Utilities
      const isDataPdf = (u) => typeof u === 'string' && u.startsWith("data:application/pdf");
      const isBlob = (u) => typeof u === 'string' && u.startsWith("blob:");
      const isHttp = (u) => typeof u === 'string' && /^https?:\/\//i.test(u);
      const text = (v) => (v == null ? "" : String(v));

      if (!srcParam) {
        document.body.innerHTML =
          '<div class="p-6 text-center text-red-300">Missing <code>?src=</code> for PDF viewer.</div>';
        return;
      }

      let viewerObjectUrl = null;   // blob URL owned by this viewer tab (so Save/Print keep working)
      let originalSrc = srcParam;   // as provided by opener

      async function adoptSrc(u) {
        try {
          // For robustness, convert blob: or data: to this tab's own blob URL.
          if (isDataPdf(u) || isBlob(u) || isHttp(u)) {
            const resp = await fetch(u, { credentials: "include" });
            if (!resp.ok) throw new Error(`Fetch failed (${resp.status})`);
            const blob = await resp.blob();
            // Revoke old viewer URL if any
            if (viewerObjectUrl) { try { URL.revokeObjectURL(viewerObjectUrl); } catch {} }
            viewerObjectUrl = URL.createObjectURL(blob);
            frame.src = viewerObjectUrl;
          } else {
            // Unknown scheme – best effort: just set it
            frame.src = u;
          }
        } catch (err) {
          // Fallback to original src if fetch fails (e.g., blocked by CSP)
          frame.src = u;
        }
      }

      // Initialize
      adoptSrc(originalSrc);
      meta.textContent = (inspectionId ? `ID: ${inspectionId} · ` : "") + filename;

      // --- SAVE the currently open PDF (no regeneration) ---
      btnDownload.addEventListener("click", async () => {
        try {
          const current = viewerObjectUrl || originalSrc;

          if (isBlob(current) || isDataPdf(current)) {
            const a = document.createElement("a");
            a.href = current;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
          } else if (isHttp(current)) {
            const resp = await fetch(current, { credentials: "include" });
            if (!resp.ok) throw new Error(`Download failed (${resp.status})`);
            const blob = await resp.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url; a.download = filename;
            document.body.appendChild(a); a.click(); a.remove();
            URL.revokeObjectURL(url);
          } else {
            // Unknown scheme; try direct download
            const a = document.createElement("a");
            a.href = current;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
          }
        } catch (err) {
          alert("Could not save this PDF: " + (err && err.message ? err.message : err));
        }
      });

      // --- PRINT the currently open PDF (no regeneration) ---
      btnPrint.addEventListener("click", () => {
        try {
          if (frame && frame.contentWindow) {
            frame.contentWindow.focus();
            frame.contentWindow.print();
          } else {
            const w = window.open(viewerObjectUrl || originalSrc, "_blank", "noopener");
            if (w) w.addEventListener("load", () => w.print());
          }
        } catch (err) {
          alert("Could not trigger print: " + (err && err.message ? err.message : err));
        }
      });

      // --- IMPORT placeholder (Fleetio) ---
      btnImport.addEventListener("click", () => {
        alert("Fleetio Work Order import is coming soon. We will use this open PDF as the source payload.");
      });

      // --- CLOSE ---
      btnClose.addEventListener("click", () => {
        try { window.close(); } catch(_) {}
      });

      // Keep the viewer-owned blob URL alive; clean it up on unload
      window.addEventListener("beforeunload", () => {
        if (viewerObjectUrl) { try { URL.revokeObjectURL(viewerObjectUrl); } catch {} }
      });
    })();
  </script>
</body>
</html>
